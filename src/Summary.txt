* немного не по теме, при разработке нового проекта сначала пишу имплементацию, потом выковыриваю из нее абстракцию
* сперва все классы immutable, потом они могут стать mutable если это необходимо


* Не проверять больше одного объекта в одном тесте
* when write test
    1. code-first(legacy code,)
    2. test-first(new code, good design)
    3. write test every time a bug is found(immediately!!!)

TDD approach
1. (RED) Always start with the failing test, and always observe it failing.
* An example of writing a simple test case just to get you started would be:
    * The Low-Hanging Fruit. This rule says: "Start with something really simple. Implement an obvious test case."
      Writing a parameter-checking test for a function (no matter what the purpose of the function in question might be),
      or, when writing a parser, starting with the test case of passing an empty String to the parsing method and receiving null in return
    * The  Most  Informative  One. "it  does  not  matter  that  my  first  match  is  against  the  world champion - if I am going to win the whole tournament, I will have to beat him anyway".
      This is probably the test which you know you still do not know how to make pass. You will simply know which one that is.
    * First The Typical Case, Then Corner Cases.
      When implementing a vending machine, begin with a client inserting a $1 coin and selecting a product which the machine has.
    * Listen To Your Experience.
2. (GREEN) Write the Simplest Thing that Works
* There are two things to remember when writing code that is necessary in order for a test to compile:
    * ll production code should be kept in a different directory tree from the tests. I suggest following the previously described pattern and putting it in src/main/java.
    * o nothing more than the minimum required for the test to compile. Create the necessary classes and  methods, but  do not  fit  them  out  with  any  business  logic.  Remember,  we  want  to  see  our  test fail now!

3. (BLUE) Refactor code end tests

In general, test doubles are used to replace DOCs, where this allows us to: 
    * gain full control over the environment in which the SUT is running, 
    * move beyond state testing and verify interactions between the SUT and its DOCs.

Types of test doubles
TEST-DOUBLE TYPE        ALSO KNOWN AS           DESCRIPTION
dummy object            dummy                   needs to exist, no real collaboration needed
test stub               stub                    used for passing some values to the SUT ("indirect inputs")
test spy                spy
mock object             mock                    used to verify if the SUT calls specific methods of the collaborator ("indirect outputs")

* Create test doubles for all DOCs except DTO, ValueObjects or JDK Lists, Sets Maps...

The  only  situations where  I  would  consider  using  a  real  collaborator  instead  of  a  test  double  are  the following: 
    * the collaborator is very, very simple, preferably without any logic (e.g. some sort of "container" class with only accessors and mutators methods),
    * the collaborator’s logic is so simple that it is clear how to set it in the desired state (and its logic will not be enhanced in the foreseeable future). Even then, I would be highly cautious, as changes are inevitable – no matter how very unlikely they may seem!
* With state testing, the SUT is a black box.
* With interaction testing, the SUT is a white box.
* You should select arguments that belong to these three groups:
    1. expected values (AKA happy path),
    2. boundary values,
    3. strange values (AKA validity or domain).

* Можно отключить тесты с помощью @Ignore или условий Assume.assumeXXX()


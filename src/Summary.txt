* немного не по теме, при разработке нового проекта сначала пишу имплементацию, потом выковыриваю из нее абстракцию
* сперва все классы immutable, потом они могут стать mutable если это необходимо


* Не проверять больше одного объекта в одном тесте
* when write test
    1. code-first(legacy code,)
    2. test-first(new code, good design)
    3. write test every time a bug is found(immediately!!!)

TDD approach
1. (RED) Always start with the failing test, and always observe it failing.
* An example of writing a simple test case just to get you started would be:
    * The Low-Hanging Fruit. This rule says: "Start with something really simple. Implement an obvious test case."
      Writing a parameter-checking test for a function (no matter what the purpose of the function in question might be),
      or, when writing a parser, starting with the test case of passing an empty String to the parsing method and receiving null in return
    * The  Most  Informative  One. "it  does  not  matter  that  my  first  match  is  against  the  world champion - if I am going to win the whole tournament, I will have to beat him anyway".
      This is probably the test which you know you still do not know how to make pass. You will simply know which one that is.
    * First The Typical Case, Then Corner Cases.
      When implementing a vending machine, begin with a client inserting a $1 coin and selecting a product which the machine has.
    * Listen To Your Experience.
2. (GREEN) Write the Simplest Thing that Works
* There are two things to remember when writing code that is necessary in order for a test to compile:
    * ll production code should be kept in a different directory tree from the tests. I suggest following the previously described pattern and putting it in src/main/java.
    * o nothing more than the minimum required for the test to compile. Create the necessary classes and  methods, but  do not  fit  them  out  with  any  business  logic.  Remember,  we  want  to  see  our  test fail now!

3. (BLUE) Refactor code end tests

In general, test doubles are used to replace DOCs, where this allows us to: 
    * gain full control over the environment in which the SUT is running, 
    * move beyond state testing and verify interactions between the SUT and its DOCs.

Types of test doubles
TEST-DOUBLE TYPE        ALSO KNOWN AS           DESCRIPTION
dummy object            dummy                   needs to exist, no real collaboration needed
test stub               stub                    used for passing some values to the SUT ("indirect inputs")
test spy                spy
mock object             mock                    used to verify if the SUT calls specific methods of the collaborator ("indirect outputs")

* Create test doubles for all DOCs except DTO, ValueObjects or JDK Lists, Sets Maps...

The  only  situations where  I  would  consider  using  a  real  collaborator  instead  of  a  test  double  are  the following: 
    * the collaborator is very, very simple, preferably without any logic (e.g. some sort of "container" class with only accessors and mutators methods),
    * the collaborator’s logic is so simple that it is clear how to set it in the desired state (and its logic will not be enhanced in the foreseeable future). Even then, I would be highly cautious, as changes are inevitable – no matter how very unlikely they may seem!
* With state testing, the SUT is a black box.
* With interaction testing, the SUT is a white box.
* You should select arguments that belong to these three groups:
    1. expected values (AKA happy path),
    2. boundary values,
    3. strange values (AKA validity or domain).

* Можно отключить тесты с помощью @Ignore или условий Assume.assumeXXX()
* В Mokito можно подменять методы с помощью when(mock).thenReturn(somthing) также можно подменять void методы doNothing().when() и doAnswer().when() or doThrow().when()

* It is time to list the advantages of matchers, which are numerous:
	* they enhance code readability, 
	* they help us to write assertions on the right abstraction level, 
	* they help to remove logic from tests (and encapsulate it within the matchers’ classes), 
	* they are highly reusable, which is very important if your domain objects are complex and are tested with multiple test scenarios, 
	* many matchers are available directly from matcher libraries - including specific matchers for work with collections (as shown in Section 6.12) or exceptions (see Section 6.4), 
	* writing custom matchers is a relatively simple task. 

The list below gives only a subset of all of the matchers available:
	* any() matches any object (or null), 
	* anyVararg() matches any number and values of arguments, 
	* isNull(), isNotNull() match null and not-null values respectively, 
	* anyBoolean(),  anyByte(),  anyChar(),  anyDouble(),  anyFloat(),  anyInt(),  anyLong(),  anyShort(), anyString() match these Java types (or null), 
	* isA(Class<T> clazz) matches any object of a given class, 
	* same(T value) matches an object which is the same (==) to a given object, 
	* anyCollection(),  anyList(),  anyMap(),  anySet()  matches  any  kind  of  instance  of  each sort  of collection (or null), 
	* refEq(T value, String... excludeFields) matches an object that is reflection-equal to the given value; allows us to specify excluded fields, not to be taken into account, 
	* eq(boolean value), eq(byte value), eq(char value), eq(double value), eq(float value), eq(int value), eq(long value), eq(short value), eq(T value) - matches values which are equal to given arguments.
	* startsWith(String prefix), endsWith(String suffix) match a string that starts/ends with the prefix/ suffix that is given, 
	* contains(String substring) matches a string that contains a given substring, 
	* matches(String regex) matches a string that matches a given regular expression.

	 All of them are listed below: •ErrorCollector: collect multiple errors in one test method 13 , •ExpectedException: make flexible assertions about thrown exceptions, •ExternalResource: start and stop a server, for example, •TemporaryFolder: create fresh files, and delete after test, •TestName: remember the test name for use during the method, •TestWatcher: add logic at events during method execution, •Timeout: cause test to fail after a set time, •Verifier: fail test if object state ends up incorrect.

